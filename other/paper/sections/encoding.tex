\section{Bit-To-Tree Encoding}

Within the context of claycodes, we are generating \textit{rooted trees} \cite{NAKANORooted}. Contrary to \textit{plane trees} \cite{NAKANOPlane}, in rooted trees the ordering among children does not matter. As a consequence, our encoding must be robust to different permutations of children while decoding (i.e. tree-to-bit), ensuring that isomorphic trees map to the same data.

Intuitively, the optimal solution would be a bijection between binary strings and rooted, unlabeled, unordered k-ary trees. However, it is not trivial whether such bijection would yield trees that are wide enough to be easily packed in practice. Therefore, we opted for an empirical approach and explored different different encoding strategies and evaluated them.

\subsection[strategies]{Encoding Strategies}

We explain squares etc.

\subsection[encodingEval]{Evaluation}

We compare the different strategies among each other.

\subsection[generation]{Generation and data capacity}

We compare the data capacity of claycodes to QR codes using the best encoding strategy to our knowledge. Here, give an idea of how the packer works.
